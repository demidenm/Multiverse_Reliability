---
title: "Reliability_SimSummary"
author: "<h3>by Michael Demidenko</h3>"
date: "`r format(Sys.time(), '%B %Y')`"
output:
  html_document:
    theme: united
    highlight: tango
    toc: yes
    number_sections: yes
    toc_depth: 2
    toc_float:
      collapsed: yes
      smooth_scroll: yes
    code_folding: hide
    self_contained: yes
  pdf_document:
    toc: yes
    toc_depth: '2'
tags: []
subtitle: <h2><u>Reliability, fMRI, tasks </u></h2>
---


```{r message=FALSE, warning=FALSE, include=FALSE}
if (!require("pacman")) install.packages("pacman")

pacman::p_load(tidyverse, ggplot2, knitr, kableExtra, ggpubr, lme4, sjPlot, specr, ggrain, neuRosim, emmeans)

session_info = sessionInfo()
system=session_info[[1]][1]
R_vers = session_info[[1]][13]
```

The packages are automatically loaded using `pacman`. The reported .html was last ran on the system: `r system` and R version: `r R_vers`

# Sim data {.tabset}

First, for the `Stage 1 registered report` some ICC distributions are simulated, aiming for a bimodial distribution to pick from and some specific categories (e.g., low, high, medium). Since `rnorm` will simulate beyond what is preferred, subseting < 1.00 and > -(.15).

## simulate ICC categories
```{r cars}
# three  diff ICC groups
# Elliott et al & Noble et al have largely reported a concentration around .3-.5. Here, simulate
# based on four levels, where min > -.15 and max is < 1.00
low_neg <- rnorm(10000, mean = 0, sd = 0.05)
low <- rnorm(10000, mean = 0.15, sd = 0.05) %>% subset(. < 1 & . > -.15)
mid <- rnorm(10000, mean = 0.45, sd = 0.1) %>% subset(. < 1 & . > -.15)
high <- rnorm(10000, mean = 0.7, sd = 0.2) %>% subset(. < 1 & . > -.15)
values <- c(low_neg, low, mid,high)
```

plotting histogram for all values
```{r}
hist(values, breaks = 10, col = "gray", xlab = "Values", main = "Bimodal Distribution of ICCs")
```

## defining & creating model permutations

Here, permutations are based on FWHM = five options, Motion = six options, Task Models = three options, Task Contrasts = four options, across three studies total `r 5*6*3*4` options that will be the "final" simulated dataset.

```{r}
fwhm_ops = c(4,5,6,7,8) # five FWHM

motion_ops = c("None", "Regress_TransRot","Regress_Derivatives","Regress_1st8aCompCor",
               "Censor_mfd","Excl_mFD") # fd cutoff, => .9

taskmod_ops = c("Cue_CueDur","Cue_CueFixDur","Fix_FixDur")
taskcontrast_ops = c("BigWin_v_Neut","BigWin_v_Base","SmWin_v_Neut","SmWin_v_Base")

studies = c("MLS","ABCD","AHRB")

# permutations of the variables & setting up for loop
var_permutations <- as.matrix(expand.grid(
  study = studies, fwhm = fwhm_ops, motion = motion_ops, 
  modeltype = taskmod_ops, contrast = taskcontrast_ops))
```

Creating empty DF to store info in
```{r}
df = data.frame(study = character(), fwhm = numeric(),
                motion = character(), contrast = character(), modeltype = character(),
                med_icc = numeric())
```


## Specifying sim ICCs

Here, using an abstract method (i.e., several if/else rules) to specify from which category of ICCs to sample from for specific modeling options. Note, this doesnt result in a covariance within studies, so the within-subj variance is likely to be random thus zero.

```{r}
set.seed(1000)
# simulate across study
for (row in 1:nrow(var_permutations)) {
  
  
  tmp_fwhm =    var_permutations[row,"fwhm"]
  tmp_motion =  var_permutations[row,"motion"]
  tmp_contrast =    var_permutations[row,"contrast"]
  tmp_model =    var_permutations[row,"modeltype"]
  tmp_study = var_permutations[row,"study"]
  
  df[row,"fwhm"] <- tmp_fwhm
  df[row,"motion"] <- tmp_motion
  df[row,"contrast"] <- tmp_contrast
  df[row,"modeltype"] <- tmp_model
  df[row,"study"] <- tmp_study

  if (tmp_fwhm %in% c(7,8)) {
    if (tmp_motion %in% c("Regress_TransRot", "Regress_Derivatives","Regress_1st8aCompCor")) {
      if (tmp_model %in% c("Cue_CueDur","Cue_CueFixDur")) {
        if (tmp_contrast=="BigWin_v_Neut") {
          df[row,"med_icc"] <- sample(x = high, size = 1,replace = FALSE)
        } else {
          df[row,"med_icc"] <- sample(x = mid, size = 1,replace = FALSE)
        }
      } else {
        df[row,"med_icc"] <- sample(x = values, size = 1,replace = FALSE)
      }
    } else {
      df[row,"med_icc"] <- sample(x = values, size = 1,replace = FALSE)
    }
  } else {
    if (tmp_motion %in% c("Regress_TransRot", "Regress_Derivatives","Regress_1st8aCompCor")) {
      if (tmp_model %in% c("Cue_CueDur","Cue_CueFixDur")) {
        if (tmp_contrast=="BigWin_v_Neut") {
          df[row,"med_icc"] <- sample(x = mid, size = 1,replace = FALSE)
        } else {
          df[row,"med_icc"] <- sample(x = low, size = 1,replace = FALSE)
        }
      } else {
        df[row,"med_icc"] <- sample(x = low, size = 1,replace = FALSE)
      }
    } else {
      df[row,"med_icc"] <- sample(x = low_neg, size = 1,replace = FALSE)
    }
  }
}
```

releving and specifying factors so things are interpretable in the heiarchical models.
```{r}
# level/relabel
df$motion = relevel(as.factor(df$motion), ref = "None", 
                     levels = c("None","Censor_mfd","Excl_mFD",
                                "Regress_1st8aCompCor","Regress_Derivatives",
                                "Regress_TransRot"))
df$modeltype = relevel(as.factor(df$modeltype), ref = "Cue_CueDur", 
                     levels = c("Cue_CueDur","Cue_CuFixDur","Fix_FixDur"))
df$contrast = relevel(as.factor(df$contrast), ref = "BigWin_v_Base", 
                     levels = c("BigWin_v_Base","BigWin_v_Neut","SmWin_v_Base","SmWin_v_Neut"))

```

***
***

# Results: ICCs across analytic approaches {.tabset}

Below, running the steps to summarize the different ICCs from the model combinations `r 5*6*3*4` for each study

## plot distribution

Plotting overall and for each of [four] categories

```{r}
icc_dist = df %>% 
  ggplot(aes(x = med_icc)) + 
  geom_histogram(bins = 50, fill = "white", colour = "black") +
  ggtitle("Overall Distribution") +
  theme_minimal()


fwhm_dist = df %>% 
  ggplot(aes(x = med_icc)) +
  geom_histogram(bins = 50, fill = "white", colour = "black") +
  facet_wrap(~fwhm) +
  ggtitle("Distribution by FWHM category") +
  theme_minimal()


motion_dist = df %>% 
  ggplot(aes(x = med_icc)) +
  geom_histogram(bins = 50, fill = "white", colour = "black") +
  facet_wrap(~motion) +
  ggtitle("Distribution by Motion category") +
  theme_minimal()

contrast_dist = df %>% 
  ggplot(aes(x = med_icc)) +
  geom_histogram(bins = 50, fill = "white", colour = "black") +
  facet_wrap(~contrast) +
  ggtitle("Distribution by Contrast category") +
  theme_minimal()

modeltype_dist = df %>% 
  ggplot(aes(x = med_icc)) +
  geom_histogram(bins = 50, fill = "white", colour = "black") +
  facet_wrap(~modeltype) +
  ggtitle("Distribution by Model Type category") +
  theme_minimal()

icc_dist 
fwhm_dist
motion_dist
contrast_dist
modeltype_dist

```
Creating rainclouds via [ggrain](https://cran.r-project.org/web/packages/ggrain/vignettes/ggrain.html)

```{r}
fwhm_rg = df %>% ggplot(aes(x = fwhm, y = med_icc, fill = fwhm, color = fwhm)) +
  geom_rain(alpha = .5, rain.side = 'l',
            boxplot.args = list(color = "black", outlier.shape = NA),
            boxplot.args.pos = list(
              position = ggpp::position_dodgenudge(x = .1), width = 0.1
            )) +
  theme_classic() +
  ggtitle("Distribution by FWHN category") +
  scale_fill_brewer(palette = 'Dark2') +
  scale_color_brewer(palette = 'Dark2') +
  guides(fill = 'none', color = 'none') +
  theme(text = element_text(family = "Times New Roman"),
        axis.text = element_text(size = 10),
        axis.title = element_text(size = 10),
        legend.text = element_text(size = 10),
        legend.title = element_text(size = 10),
        plot.title = element_text(size = 16))


motion_rg = df %>% ggplot(aes(x = motion, y = med_icc, fill = motion, color = motion)) +
  geom_rain(alpha = .5, rain.side = 'l',
            boxplot.args = list(color = "black", outlier.shape = NA),
            boxplot.args.pos = list(
              position = ggpp::position_dodgenudge(x = .1), width = 0.1
            )) +
  theme_classic() +
  ggtitle("Distribution by Motion category") +
  scale_fill_brewer(palette = 'Dark2') +
  scale_color_brewer(palette = 'Dark2') +
  guides(fill = 'none', color = 'none') +
  theme(text = element_text(family = "Times New Roman"),
        axis.text = element_text(size = 10),
        axis.title = element_text(size = 10),
        legend.text = element_text(size = 10),
        legend.title = element_text(size = 10),
        plot.title = element_text(size = 16))

modeltype_rg = df %>% ggplot(aes(x = modeltype, y = med_icc, fill = modeltype, color = modeltype)) +
  geom_rain(alpha = .5, rain.side = 'l',
            boxplot.args = list(color = "black", outlier.shape = NA),
            boxplot.args.pos = list(
              position = ggpp::position_dodgenudge(x = .1), width = 0.1
            )) +
  theme_classic() +
  ggtitle("Distribution by Model Type category") +
  scale_fill_brewer(palette = 'Dark2') +
  scale_color_brewer(palette = 'Dark2') +
  guides(fill = 'none', color = 'none') +
  theme(text = element_text(family = "Times New Roman"),
        axis.text = element_text(size = 10),
        axis.title = element_text(size = 10),
        legend.text = element_text(size = 10),
        legend.title = element_text(size = 10),
        plot.title = element_text(size = 16))

contrast_rg = df %>% ggplot(aes(x = contrast, y = med_icc, fill = contrast, color = contrast)) +
  geom_rain(alpha = .5, rain.side = 'l',
            boxplot.args = list(color = "black", outlier.shape = NA),
            boxplot.args.pos = list(
              position = ggpp::position_dodgenudge(x = .1), width = 0.1
            )) +
  theme_classic() +
  ggtitle("Distribution by Contrast category") +
  scale_fill_brewer(palette = 'Dark2') +
  scale_color_brewer(palette = 'Dark2') +
  guides(fill = 'none', color = 'none') +
  theme(text = element_text(family = "Times New Roman"),
        axis.text = element_text(size = 10),
        axis.title = element_text(size = 10),
        legend.text = element_text(size = 10),
        legend.title = element_text(size = 10),
        plot.title = element_text(size = 16))

fwhm_rg
motion_rg
modeltype_rg
contrast_rg

```

## summaries of model types

```{r warning=FALSE}
summary_icc = df %>% 
  group_by(fwhm, motion, modeltype, contrast) %>% 
  summarise(across(("med_icc"), list(min = min, max = max, mean = mean, median = median))) %>% 
  as.data.frame()

summary_icc %>% 
  arrange(desc(med_icc_min)) %>% 
  slice(1:10)

summary_icc %>% 
  arrange(desc(med_icc_max)) %>% 
  slice(1:10)

summary_icc %>% 
  arrange(desc(med_icc_mean)) %>% 
  slice(1:10)
```


## Fitting HLM

Below using `lmer` to fit HLM model. The model has random intercept (sample). e.g., Level 1 model: Median ICC ~ Beta Estimates. Level 2 model: Random intercept. For reproducible reporting using [tab_model](https://www.rdocumentation.org/packages/sjPlot/versions/2.8.4/topics/tab_model)



```{r warning=FALSE}
model = lmer(med_icc ~ fwhm + motion + modeltype + contrast + (1 | study), data = df)

tab_model(model)
```

Using [emmeans](https://www.rdocumentation.org/packages/emmeans/versions/1.3.2/topics/emmeans-package) to control type I error rate of controls via [Tukey's Honest Significant Test](https://en.wikipedia.org/wiki/Tukey%27s_range_test)

```{r}
# Model comparisons
mod1_lmer_obs = as.numeric(summary(model)[3]$devcomp$dims[1])
emm_options(lmerTest.limit = mod1_lmer_obs)


# contrast fwhm
mod1_thsd = emmeans(object = model, specs = pairwise ~ fwhm, pbkrtest.limit = mod1_lmer_obs)
mod1_thsd$contrasts %>% summary(infer = TRUE) %>% 
  kbl(digits = 4, caption = "Contrast Tukey HSD: FWHM") %>%  kable_styling()


# contrast task contrast
mod2_thsd = emmeans(object = model, specs = pairwise ~ contrast, pbkrtest.limit = mod1_lmer_obs)
mod2_thsd$contrasts %>% summary(infer = TRUE) %>% 
  kbl(digits = 4, caption = "Contrast Tukey HSD: Contrast") %>%  kable_styling()

# contrast motion
mod3_thsd = emmeans(object = model, specs = pairwise ~ motion, pbkrtest.limit = mod1_lmer_obs)
mod3_thsd$contrasts %>% summary(infer = TRUE) %>% 
  kbl(digits = 4, caption = "Contrast Tukey HSD: Motion Corr") %>%  kable_styling()

# contrast modeltype
mod4_thsd = emmeans(object = model, specs = pairwise ~ modeltype, pbkrtest.limit = mod1_lmer_obs)
mod4_thsd$contrasts %>% summary(infer = TRUE) %>% 
  kbl(digits = 4, caption = "Contrast Tukey HSD: Model Type ") %>%  kable_styling()
```

## Specification Curve

Creating data in a format that is compatible with [specr](https://cran.r-project.org/web/packages/specr/specr.pdf). Needs: estimate (i.e., ICC), std.error, conf.high, conf.low.
```{r}
# create specr plot for med_icc averages for 
# first, combine independent model vars into string to create average for each model type
df$model_type <- paste(df$fwhm,df$motion,df$contrast,df$modeltype,sep = "-")

# calculate the avg estimate of ICC across study, standard error and +/- 95% confidence interval. In complete version
df_summ <- df %>% 
  group_by(model_type) %>% 
  summarise(estimate = mean(med_icc), std.error = sd(med_icc)/sqrt(length(med_icc))) %>% 
  mutate(conf.low = estimate - 1.96 * std.error, conf.high = estimate + 1.96 * std.error) %>% 
  separate(col = model_type, into = c("fwhm","motion","contrast","modeltype"), sep = "-", remove = FALSE)

```


### All models

creating combined panel 1 and panel 2 for all model permutations first.

```{r warning=FALSE}
plot_a = plot_curve(df = df_summ, ci = TRUE, desc = FALSE, legend = FALSE, null = 0)

plot_b <- plot_choices(df = df_summ, choices = c("fwhm", "motion","contrast","modeltype"), desc = F, null = 0) +
  labs(y = "Variables", x = "Ordered Specification Curve \n ICC coefficient")

cowplot::plot_grid(plot_a, plot_b, ncol = 1, align = "v", axis = 'tblr',
                   labels = c('A', 'B'), rel_heights = c(1, 2),
                   label_fontfamily = "Times", label_size = 12)
```


### subset models

Creating model that is subset to visualize reliability for the top (>75th) and bottom (< 25th) quartile

```{r warning=FALSE}
# get 75th/25th qunatiles
top_75q = as.numeric(quantile(df_summ$estimate, .75))
bot_25q = as.numeric(quantile(df_summ$estimate, .25))
df_summ_subset = df_summ %>% 
  filter(estimate < bot_25q | estimate > top_75q)

# subset plots
plot_a_sub = plot_curve(df = df_summ_subset, ci = TRUE, desc = FALSE, legend = FALSE, null = 0)

plot_b_sub <- plot_choices(df = df_summ_subset, choices = c("fwhm", "motion","contrast","modeltype"), desc = F, null = 0) +
  labs(y = "Variables", x = "Ordered Specification Curve \n ICC coefficient")

cowplot::plot_grid(plot_a_sub, plot_b_sub, ncol = 1, align = "v", axis = 'tblr',
                   labels = c('A', 'B'), rel_heights = c(1, 2),
                   label_fontfamily = "Times", label_size = 12)
```


***
***

# Design efficiency Examples {.tabset}

The ability to estimate the BOLD signal in the timeseries, efficiency plays a significant role. See issues discussed by series of videos from [Jeanette Mumford](https://www.youtube.com/playlist?list=PLB2iAtgpI4YEnBdb_jDGmMcdGoIBwhCCY). The MID task, has historically different ways of defining the "Anticipation" phase. Previously, it started by modeling the fixation phase/duration and later some have used the cue/duration. However, the issues have been rarely cleared up in the literature as it is challenging to decipher from the information provided in papers what is defined as the anticipation phase and duration. Hence, up to three models can be created in the design matrix.

Below, using the efficiency calculation tutorial from Dr [Mumford](https://github.com/jmumford/nhwEfficiency) to estimate the effieiency of the three different models that can be estimated in this version of the MID task.

## Pulling Behavior Data

First, the behavior data is pulled from the events files for each subject and each run. Some subjects are excluded because they lack hit/miss trials which causes an error in the step using [neuRosim](https://www.jstatsoft.org/article/view/v044i10).

```{r}
# location for subjects run behavior data
# update path as needed
dir = "/Users/michaeldemidenko/Desktop/Academia/UM/2_AHRB/Projects/BIDS/Beh/MID_W1/"

# getting list of file names
beh_files = list.files(dir)

# removing subjects that dont have some Hit/Miss for outcome, as there are zero values for complete calculation
beh_files_ct = beh_files[-c(12,19,34,39,46,120,140)]
#   sub-07_ses-1_task-mid_run-02_events.tsv
#   sub-100_ses-1_task-mid_run-01_events.tsv
#   sub-107_ses-1_task-mid_run-02_events.tsv
#   sub-12_ses-1_task-mid_run-01_events.tsv
#   sub-15_ses-1_task-mid_run-02_events.tsv
#   sub-52_ses-1_task-mid_run-02_events.tsv
#   sub-62_ses-1_task-mid_run-02_events.tsv
```


## Estimating efficiency from Events

Using for loop to create the the data based on the behavioral onsets/durations for efficiency results. Three different models are fit:

- `design_CueMod`: Cue Onset + Cue Duration
- `design_AntMod`: Cue Onset + (Cue Duration + Fixation Duration)
- `design_FixMod`: Fixation Onset + Fixation Duration

While the focus is on the anticipatory phase, e.g. modeling 5 cue times + associated duration, the feedback phase is modeled, too. In other words, the total model includes 15 items.

```{r}
# Null df to add to
df = NULL

# creating forloop using Jeanette Mumfords recommended code from Neurohack - https://github.com/jmumford/nhwEfficiency
# tailored to work with behavior data collected for MID task data

#set TR, vols, effect size (amplitude) and run and mri length
tr = .8 
vols = 407
effect_size = 1
run_len = vols*tr
mri_len = seq(1,407,1)
  
for (f in beh_files_ct) {
  
  # Combining directory and file path to open .csv
  beh_dat = read.csv(paste(dir,f,sep=""),sep = '\t')
  
  # subj/run labels to use in later df creation
  str_vals =data.frame(str_split(f,'_'))
  sub = str_vals[1,1]
  run = str_vals[4,1]
  
  # convert one of the outcome items foor Neutral condition so it is differently labeled for Hit/Miss
  beh_dat <- beh_dat %>% 
    mutate(TRIAL_RESULT = if_else(TRIAL_RESULT!="No money at stake!",TRIAL_RESULT,
                                  if_else(PROBE_HIT==1,TRIAL_RESULT,"No Money At Stake, MISS")))
  
  #
  
  ### Anticipation
  
  # Onsets
  BW_ons_1 <-   beh_dat$CUE_ONSET[beh_dat$TRIAL_TYPE=="LargeGain"]
  SW_ons_1 <-   beh_dat$CUE_ONSET[beh_dat$TRIAL_TYPE=="SmallGain"]
  Neut_ons_1 <- beh_dat$CUE_ONSET[beh_dat$TRIAL_TYPE=="NoMoneyStake"]
  BL_ons_1 <-   beh_dat$CUE_ONSET[beh_dat$TRIAL_TYPE=="LargeLoss"]
  SL_ons_1 <-   beh_dat$CUE_ONSET[beh_dat$TRIAL_TYPE=="SmallLoss"]
  
  BW_ons_2 <-   beh_dat$FIXATION_ONSET[beh_dat$TRIAL_TYPE=="LargeGain"]
  SW_ons_2 <-   beh_dat$FIXATION_ONSET[beh_dat$TRIAL_TYPE=="SmallGain"]
  Neut_ons_2 <- beh_dat$FIXATION_ONSET[beh_dat$TRIAL_TYPE=="NoMoneyStake"]
  BL_ons_2 <-   beh_dat$FIXATION_ONSET[beh_dat$TRIAL_TYPE=="LargeLoss"]
  SL_ons_2 <-   beh_dat$FIXATION_ONSET[beh_dat$TRIAL_TYPE=="SmallLoss"]
  
  # durations
  BW_dur1 <-   beh_dat$CUE_DURATION[beh_dat$TRIAL_TYPE=="LargeGain"]   
  SW_dur1 <-   beh_dat$CUE_DURATION[beh_dat$TRIAL_TYPE=="SmallGain"]   
  Neut_dur1 <- beh_dat$CUE_DURATION[beh_dat$TRIAL_TYPE=="NoMoneyStake"]
  BL_dur1 <-   beh_dat$CUE_DURATION[beh_dat$TRIAL_TYPE=="LargeLoss"]   
  SL_dur1 <-   beh_dat$CUE_DURATION[beh_dat$TRIAL_TYPE=="SmallLoss"]   
  
  BW_dur2 <-   beh_dat$FIXATION_DURATION[beh_dat$TRIAL_TYPE=="LargeGain"]   
  SW_dur2 <-   beh_dat$FIXATION_DURATION[beh_dat$TRIAL_TYPE=="SmallGain"]   
  Neut_dur2 <- beh_dat$FIXATION_DURATION[beh_dat$TRIAL_TYPE=="NoMoneyStake"]
  BL_dur2 <-   beh_dat$FIXATION_DURATION[beh_dat$TRIAL_TYPE=="LargeLoss"]   
  SL_dur2 <-   beh_dat$FIXATION_DURATION[beh_dat$TRIAL_TYPE=="SmallLoss"]   
  
  BW_dur12 <-   beh_dat$CUE_DURATION[beh_dat$TRIAL_TYPE=="LargeGain"]   + beh_dat$FIXATION_DURATION[beh_dat$TRIAL_TYPE=="LargeGain"]   
  SW_dur12 <-   beh_dat$CUE_DURATION[beh_dat$TRIAL_TYPE=="SmallGain"]   + beh_dat$FIXATION_DURATION[beh_dat$TRIAL_TYPE=="SmallGain"]   
  Neut_dur12 <- beh_dat$CUE_DURATION[beh_dat$TRIAL_TYPE=="NoMoneyStake"]+ beh_dat$FIXATION_DURATION[beh_dat$TRIAL_TYPE=="NoMoneyStake"]
  BL_dur12 <-   beh_dat$CUE_DURATION[beh_dat$TRIAL_TYPE=="LargeLoss"]   + beh_dat$FIXATION_DURATION[beh_dat$TRIAL_TYPE=="LargeLoss"]   
  SL_dur12 <-   beh_dat$CUE_DURATION[beh_dat$TRIAL_TYPE=="SmallLoss"]   + beh_dat$FIXATION_DURATION[beh_dat$TRIAL_TYPE=="SmallLoss"]   
  
  
  ### Feedback
  # Onsets
  BW_Hit_ons <-   beh_dat$FEEDBACK_ONSET[beh_dat$TRIAL_RESULT=="You earn $5!"]
  SW_Hit_ons <-   beh_dat$FEEDBACK_ONSET[beh_dat$TRIAL_RESULT=="You earn $0.20!"]
  Neut_Hit_ons <- beh_dat$FEEDBACK_ONSET[beh_dat$TRIAL_RESULT=="No money at stake!"]
  BL_Hit_ons <-   beh_dat$FEEDBACK_ONSET[beh_dat$TRIAL_RESULT=="You keep $5!"]
  SL_Hit_ons <-   beh_dat$FEEDBACK_ONSET[beh_dat$TRIAL_RESULT=="You keep $0.20!"]
  
  BW_Miss_ons <-   beh_dat$FEEDBACK_ONSET[beh_dat$TRIAL_RESULT=="You did not earn $5!"]
  SW_Miss_ons <-   beh_dat$FEEDBACK_ONSET[beh_dat$TRIAL_RESULT=="You did not earn $0.20!"]
  Neut_Miss_ons <- beh_dat$FEEDBACK_ONSET[beh_dat$TRIAL_RESULT=="No Money At Stake, MISS"]
  BL_Miss_ons <-   beh_dat$FEEDBACK_ONSET[beh_dat$TRIAL_RESULT=="You lose $5!"]
  SL_Miss_ons <-   beh_dat$FEEDBACK_ONSET[beh_dat$TRIAL_RESULT=="You lose $0.20!"]
  
  # durations
  BW_Hit_dur <-   beh_dat$FEEDBACK_DURATION[beh_dat$TRIAL_RESULT=="You earn $5!"]
  SW_Hit_dur <-   beh_dat$FEEDBACK_DURATION[beh_dat$TRIAL_RESULT=="You earn $0.20!"]
  Neut_Hit_dur <- beh_dat$FEEDBACK_DURATION[beh_dat$TRIAL_RESULT=="No money at stake!"]
  BL_Hit_dur <-   beh_dat$FEEDBACK_DURATION[beh_dat$TRIAL_RESULT=="You keep $5!"]
  SL_Hit_dur <-   beh_dat$FEEDBACK_DURATION[beh_dat$TRIAL_RESULT=="You keep $0.20!"]
  
  BW_Miss_dur <-   beh_dat$FEEDBACK_DURATION[beh_dat$TRIAL_RESULT=="You did not earn $5!"]
  SW_Miss_dur <-   beh_dat$FEEDBACK_DURATION[beh_dat$TRIAL_RESULT=="You did not earn $0.20!"]
  Neut_Miss_dur <- beh_dat$FEEDBACK_DURATION[beh_dat$TRIAL_RESULT=="No Money At Stake, MISS"]
  BL_Miss_dur <-   beh_dat$FEEDBACK_DURATION[beh_dat$TRIAL_RESULT=="You lose $5!"]
  SL_Miss_dur <-   beh_dat$FEEDBACK_DURATION[beh_dat$TRIAL_RESULT=="You lose $0.20!"]
  
  
  ## model 1 (cue only), creating a list of values for Onset and Duration
  CueMod_ons = list(BW_ons_1, SW_ons_1,Neut_ons_1,BL_ons_1,SL_ons_1,
                  BW_Hit_ons, SW_Hit_ons, Neut_Hit_ons, BL_Hit_ons,SL_Hit_ons,
                  BW_Miss_ons,SW_Miss_ons, Neut_Miss_ons, BL_Miss_ons,SL_Miss_ons
                  )
  CueMod_dur = list(BW_dur1,SW_dur1,Neut_dur1,BL_dur1,SL_dur1,
                  BW_Hit_dur, SW_Hit_dur, Neut_Hit_dur, BL_Hit_dur,SL_Hit_dur,
                  BW_Miss_dur,SW_Miss_dur, Neut_Miss_dur, BL_Miss_dur,SL_Miss_dur
                  )
  
  # Using specifydesign to create the HRF Cue Model based on inputs:
  # onsets of the specified model
  # durations of the specificated model
  # the list of effect size (or amplitudes) used for each stimulus in model
  # Tr and total time to create the length of HRF using the convolved double-gamma
  # condition names is a list of labels for the Input onset labels
  Cue_Mod <- specifydesign(onsets = CueMod_ons,
                      durations = CueMod_dur, 
                      effectsize =list(1,1,1,1,1,
                                       1,1,1,1,1,
                                       1,1,1,1,1),
                      TR = tr, totaltime = run_len, conv = "double-gamma",
                      cond.names = list("BW","SW","Neut","BL","SL",
                                        "BWhit","SWhit","NEUThit","BLhit","SLhit",
                                        "BWmss","SWmss","NEUTmss","BLmss","SLmss")
                      )
  
  
  # Model 2 (fixation only)
  ## model 1
  FixMod_ons = list(BW_ons_2, SW_ons_2,Neut_ons_2,BL_ons_2,SL_ons_2,
                    BW_Hit_ons, SW_Hit_ons, Neut_Hit_ons, BL_Hit_ons,SL_Hit_ons,
                    BW_Miss_ons,SW_Miss_ons, Neut_Miss_ons, BL_Miss_ons,SL_Miss_ons
  )
  FixMod_dur = list(BW_dur2,SW_dur2,Neut_dur2,BL_dur2,SL_dur2,
                    BW_Hit_dur, SW_Hit_dur, Neut_Hit_dur, BL_Hit_dur,SL_Hit_dur,
                    BW_Miss_dur,SW_Miss_dur, Neut_Miss_dur, BL_Miss_dur,SL_Miss_dur
  )
  
  
  Fix_Mod <- specifydesign(onsets = FixMod_ons,
                           durations = FixMod_dur, 
                           effectsize =list(1,1,1,1,1,
                                            1,1,1,1,1,
                                            1,1,1,1,1),
                           TR = tr, totaltime = run_len, conv = "double-gamma",
                           cond.names = list("BW","SW","Neut","BL","SL",
                                             "BWhit","SWhit","NEUThit","BLhit","SLhit",
                                             "BWmss","SWmss","NEUTmss","BLmss","SLmss")
  )
  
  #Anticipation model cue onset & cue + fix dur
  ## model 1
  AntMod_ons = list(BW_ons_1, SW_ons_1,Neut_ons_1,BL_ons_1,SL_ons_1,
                    BW_Hit_ons, SW_Hit_ons, Neut_Hit_ons, BL_Hit_ons,SL_Hit_ons,
                    BW_Miss_ons,SW_Miss_ons, Neut_Miss_ons, BL_Miss_ons,SL_Miss_ons
  )
  AntMod_dur = list(BW_dur12,SW_dur12,Neut_dur12,BL_dur12,SL_dur12,
                    BW_Hit_dur, SW_Hit_dur, Neut_Hit_dur, BL_Hit_dur,SL_Hit_dur,
                    BW_Miss_dur,SW_Miss_dur, Neut_Miss_dur, BL_Miss_dur,SL_Miss_dur
  )
  
  
  Ant_Mod <- specifydesign(onsets = AntMod_ons,
                           durations = AntMod_dur, 
                           effectsize =list(1,1,1,1,1,
                                            1,1,1,1,1,
                                            1,1,1,1,1),
                           TR = tr, totaltime = run_len, conv = "double-gamma",
                           cond.names = list("BW","SW","Neut","BL","SL",
                                             "BWhit","SWhit","NEUThit","BLhit","SLhit",
                                             "BWmss","SWmss","NEUTmss","BLmss","SLmss")
  )
  
  design_CueMod <- data.frame("TR" = mri_len, Cue_Mod)

    # create design matrix + test contrast
  CueMod_mat = cbind("Inter" = rep(1,length(design_CueMod$BW)),
                     design_CueMod[2:16])
  # Plot fixation model and create design matrix
  design_FixMod <- data.frame("TR" = mri_len, Fix_Mod)
  
  # create design matrix 
  FixMod_mat = cbind("Inter" = rep(1,length(design_FixMod$BW)),
                     design_FixMod[2:16])
  
  # Plot anticipation model and create design matrix
  design_AntMod <- data.frame("TR" = mri_len, Ant_Mod)
  

  
  # create design matrix 
  AntMod_mat = cbind("Inter" = rep(1,length(design_AntMod$BW)),
                     design_AntMod[2:16])
  
  # setting up contrasts to estimate efficiency
  
  LGain = c(0,
          1,0,-1,0,0, # large gain versus neutral
          0,0,0,0,0,0,0,0,0,0
          )
  
  LGain_CueMod = 1/(t(LGain)%*%solve(t(CueMod_mat)%*%as.matrix(CueMod_mat))%*%LGain)
  LGain_AntMod = 1/(t(LGain)%*%solve(t(AntMod_mat)%*%as.matrix(AntMod_mat))%*%LGain)
  LGain_FixMod = 1/(t(LGain)%*%solve(t(FixMod_mat)%*%as.matrix(FixMod_mat))%*%LGain)
  
  SGain = c(0,
          0,1,-1,0,0, # small gain versus neutral
          0,0,0,0,0,0,0,0,0,0
          )
  
  SGain_CueMod = 1/(t(SGain)%*%solve(t(CueMod_mat)%*%as.matrix(CueMod_mat))%*%SGain)
  SGain_AntMod = 1/(t(SGain)%*%solve(t(AntMod_mat)%*%as.matrix(AntMod_mat))%*%SGain)
  SGain_FixMod = 1/(t(SGain)%*%solve(t(FixMod_mat)%*%as.matrix(FixMod_mat))%*%SGain)
  
  
  LGain_bl = c(0,
          1,0,0,0,0, # large gain versus baseline
          0,0,0,0,0,0,0,0,0,0
          )
  
  LGain_bl_CueMod = 1/(t(LGain_bl)%*%solve(t(CueMod_mat)%*%as.matrix(CueMod_mat))%*%LGain_bl)
  LGain_bl_AntMod = 1/(t(LGain_bl)%*%solve(t(AntMod_mat)%*%as.matrix(AntMod_mat))%*%LGain_bl)
  LGain_bl_FixMod = 1/(t(LGain_bl)%*%solve(t(FixMod_mat)%*%as.matrix(FixMod_mat))%*%LGain_bl)
  
  SGain_bl = c(0,
          0,1,0,0,0, # small gain versus baseline
          0,0,0,0,0,0,0,0,0,0
          )
  
  SGain_bl_CueMod = 1/(t(SGain_bl)%*%solve(t(CueMod_mat)%*%as.matrix(CueMod_mat))%*%SGain_bl)
  SGain_bl_AntMod = 1/(t(SGain_bl)%*%solve(t(AntMod_mat)%*%as.matrix(AntMod_mat))%*%SGain_bl)
  SGain_bl_FixMod = 1/(t(SGain_bl)%*%solve(t(FixMod_mat)%*%as.matrix(FixMod_mat))%*%SGain_bl)
  
  
  # VIF w/o intercept
  #diag(solve(cor(CueMod_mat[,2:16])))
  #diag(solve(cor(FixMod_mat[,2:16])))
  #diag(solve(cor(AntMod_mat[,2:16])))
  sub_details = c(sub, run, 
                  LGain_CueMod, LGain_AntMod, LGain_FixMod,
                  SGain_CueMod, SGain_AntMod, SGain_FixMod,
                  # implicit baseline
                  LGain_bl_CueMod, LGain_bl_AntMod, LGain_bl_FixMod,
                  SGain_bl_CueMod, SGain_bl_AntMod, SGain_bl_FixMod)
  
  df = rbind(df,sub_details)
  
}
```


## Plotting Timings/Efficiency

Pltting the BOLD timeseries based on each cue type from the provided behavioral data. By visualizing the different models, can observe how duration and amplitude shift between them. As a reminder, the models include:

- `design_CueMod`: Cue Onset + Cue Duration
- `design_AntMod`: Cue Onset + (Cue Duration + Fixation Duration)
- `design_FixMod`: Fixation Onset + Fixation Duration

### Timing by condition & design

```{r}

pal <- c("#000000","#004949","#009292","#ff6db6","#ffb6db",
 "#490092","#006ddb","#b66dff","#6db6ff","#b6dbff",
 "#920000","#924900","#db6d00","#24ff24","#ffff6d") 
 
cuemod_plt = design_CueMod %>% 
  gather("Cue","Value", BW:SLmss) %>% 
  ggplot(aes(x = TR, y = Value, colour = Cue)) +
  geom_line() +
  facet_wrap(~Cue) +
  ggtitle("A") +
  #scale_color_brewer(palette = 'Dark2') +
  scale_color_manual(values = pal) +
  theme_minimal()+
  theme(text = element_text(family = "Times New Roman"),
        axis.text = element_text(size = 10),
        axis.title = element_text(size = 10),
        legend.text = element_text(size = 10),
        legend.title = element_text(size = 10),
        plot.title = element_text(size = 16))

antmod_plt = design_AntMod %>% 
  gather("Cue","Value", BW:SLmss) %>% 
  ggplot(aes(x = TR, y = Value, colour = Cue)) +
  geom_line() +
  facet_wrap(~Cue) +
  ggtitle("B") +
  #scale_color_brewer(palette = 'Dark2') +
  scale_color_manual(values = pal) +
  theme_minimal()+
  theme(text = element_text(family = "Times New Roman"),
        axis.text = element_text(size = 10),
        axis.title = element_text(size = 10),
        legend.text = element_text(size = 10),
        legend.title = element_text(size = 10),
        plot.title = element_text(size = 16))
  
fixmod_plt = design_FixMod %>% 
  gather("Cue","Value", BW:SLmss) %>% 
  ggplot(aes(x = TR, y = Value, colour = Cue)) +
  geom_line() +
  facet_wrap(~Cue) +
  ggtitle("C") +
  #scale_color_brewer(palette = 'Dark2') +
  scale_color_manual(values = pal) +
  theme_minimal()+
  theme(text = element_text(family = "Times New Roman"),
        axis.text = element_text(size = 10),
        axis.title = element_text(size = 10),
        legend.text = element_text(size = 10),
        legend.title = element_text(size = 10),
        plot.title = element_text(size = 16))

cuemod_plt
antmod_plt
fixmod_plt
```

### Timing by Design

The below is harder to visualize because the fast event design is shorter than the BOLD signal. Hence, events have quite a bit of overlap.

```{r}
pal <- c("#000000","#004949","#009292","#ff6db6","#ffb6db",
 "#490092","#006ddb","#b66dff","#6db6ff","#b6dbff",
 "#920000","#924900","#db6d00","#24ff24","#ffff6d") 
 
design_CueMod %>% 
  gather("Cue","Value", BW:SLmss) %>% 
  ggplot(aes(x = TR, y = Value, colour = Cue)) +
  geom_line() +
  ggtitle("Cue Onset + Cue Dur") +
  scale_color_manual(values = pal) +
  theme_minimal() +
  theme(text = element_text(family = "Times New Roman"),
        axis.text = element_text(size = 10),
        axis.title = element_text(size = 10),
        legend.text = element_text(size = 10),
        legend.title = element_text(size = 10),
        plot.title = element_text(size = 16))

design_AntMod %>% 
  gather("Cue","Value", BW:SLmss) %>% 
  ggplot(aes(x = TR, y = Value, colour = Cue)) +
  geom_line() +
  ggtitle("Cue Onset + (Cue Dur + Fix Dur)") +
  scale_color_manual(values = pal) +
  theme_minimal() +
  theme(text = element_text(family = "Times New Roman"),
        axis.text = element_text(size = 10),
        axis.title = element_text(size = 10),
        legend.text = element_text(size = 10),
        legend.title = element_text(size = 10),
        plot.title = element_text(size = 16)) 
  
design_FixMod %>% 
  gather("Cue","Value", BW:SLmss) %>% 
  ggplot(aes(x = TR, y = Value, colour = Cue)) +
  geom_line() +
  ggtitle("Fix Onset + Fix Dur") +
  scale_color_manual(values = pal) +
  theme_minimal() +
  theme(text = element_text(family = "Times New Roman"),
        axis.text = element_text(size = 10),
        axis.title = element_text(size = 10),
        legend.text = element_text(size = 10),
        legend.title = element_text(size = 10),
        plot.title = element_text(size = 16))
```

## Plotting effieincy

Plotting each effieincy model by contrast to show the estimated design efficiency for each datapoint.

```{r}
# create dataframe of details w/ long format
eff_data = as.data.frame(df)
colnames(eff_data) <- c("Sub","Run",
                        "LarGain_CueMod", "LarGain_AntMod", "LarGain_FixMod",
                        "SmGain_CueMod", "SmGain_AntMod", "SmGain_FixMod",
                        "LarGainvBase_CueMod", "LarGainvBase_AntMod", "LarGainvBase_FixMod",
                        "SmGainvBase_CueMod", "SmGainvBase_AntMod", "SmGainvBase_FixMod")

eff_data_long = eff_data %>% 
  gather("Model","Eff",LarGain_CueMod:SmGainvBase_FixMod) %>%  
  separate(col = Model, into = c("Con","Model"), sep = '_')

eff_data_long$Eff <- as.integer(eff_data_long$Eff)

# plotting
# plot by run and contrast
plot_runcon = eff_data_long %>% ggplot(aes(x = Con, y = Eff, colour = Con, fill = Con)) +
  # setting up raincloud
  geom_rain(alpha = .3, rain.side = 'l',
            boxplot.args.pos = list(
              width = 0.05, position = position_nudge(x = 0.15)),
            violin.args.pos = list(
              side = "l",
              width = 0.7, position = position_nudge(x = 0.3))) +
  # significance comparison
  ggsignif::geom_signif(
  comparisons = list(c("LarGain", "LarGainvBase"),
                     c("LarGainvBase", "SmGain"),
                     c("SmGain","LarGain"),
                     c("SmGainvBase","LarGain")
                     ),
  map_signif_level = TRUE,
  y_position = c(34,31,28,25,22),
  margin_top = 0.1) +
  # plot elements
  theme_classic() +
  scale_fill_brewer(palette = 'Dark2') +
  scale_color_brewer(palette = 'Dark2') +
  guides(fill = 'none', color = 'none') +
  labs(title = "Estimated Efficiency by Run & Contrast",
  caption = "LGain: Large Gain > Neut; SGain: Small Gain > Neut;
  LGain v BL: Large Gain > Implicit Baseline; SGain v BL: Small Gain > Implicit Baseline")+
  ylab("Estimated Effieincy")+
  scale_x_discrete(name = "Model Type",
                   labels = c("LGain","SGain","LGain v BL","SGain v BL"))+
  facet_wrap(~Run + Model)+
  theme(text = element_text(family = "Times New Roman"),
        axis.text = element_text(size = 10),
        axis.title = element_text(size = 10),
        legend.text = element_text(size = 10),
        legend.title = element_text(size = 10),
        plot.title = element_text(size = 16))

plot_runcon
```

